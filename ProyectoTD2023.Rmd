---
title: "ProyectoTD2023"
author: "Jose Garcia Mora, Lucia Chulvi Deogracia"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r eval=T, include=F}
# Especificamos las librerías necesarias en esta lista
packages = c("knitr", "ggplot2","tidyr","dplyr","readr", "tidyverse", "plotly")# use this function to check if each package is on the local machine
# if a package is installed, it will be loaded
# if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
# verify they are loaded
search()
```



```{r}
library(tidyverse)
get_data <- function(ruta){
###### cabecera digital ######
  ficheroCD <- paste0(ruta, "cabecera_FicheroDigital.DAT")
  cabecera_digital <- readBin(con = ficheroCD, what = "integer", n = 8, size = 1, signed = FALSE)
  
###### fichero digital ######
  ficheroB <- paste0(ruta, "ficheroDigital.DAT")
  datos_digitales <- readBin(con = ficheroB, what = "integer", n = 2000000, size = 1, signed = FALSE)
  
  HR1 <- datos_digitales[seq(from = 1, to = length(datos_digitales), by = 9)]
  HR2 <- datos_digitales[seq(from = 2, to = length(datos_digitales), by = 9)]
  MHR <- datos_digitales[seq(from = 3, to = length(datos_digitales), by = 9)]
  TOCO <- datos_digitales[seq(from = 4, to = length(datos_digitales), by = 9)]
  MSpO2 <- datos_digitales[seq(from = 5, to = length(datos_digitales), by = 9)]
  VCP <- datos_digitales[seq(from = 6, to = length(datos_digitales), by = 9)]
  Psistolica <- datos_digitales[seq(from = 7, to = length(datos_digitales), by = 9)]
  Pdiastolica <- datos_digitales[seq(from = 8, to = length(datos_digitales), by = 9)]
  Pmedia <- datos_digitales[seq(from = 9, to = length(datos_digitales), by = 9)]
  
  mediaVCP <- mean(VCP) # cálculo de la media de la VCP
  
  # Almacenar las variables en una lista
  df_list <- list(HR1, HR2, MHR, TOCO, MSpO2, VCP, Psistolica, Pdiastolica, Pmedia)
  
  # Calcular el número máximo de filas
  max_filas <- max(sapply(df_list, length))
  
  # Recorrer cada vector en la lista
  for (i in 1:length(df_list)) {
    # Obtener el vector actual
    vector_actual <- df_list[[i]]
    # Calcular la mediana del vector
    mediana_actual <- median(vector_actual)
    
    # Comprobar si el vector necesita relleno
    if (length(vector_actual) < max_filas) {
      # Calcular el número de filas a rellenar
      filas_relleno <- max_filas - length(vector_actual)
      
      # Rellenar el vector con la mediana
      vector_relleno <- rep(mediana_actual, filas_relleno)
      
      # Concatenar el vector original y el vector de relleno
      df_list[[i]] <- c(vector_actual, vector_relleno)
    }
  }
  
  # Convertir la lista en un data frame
  datos_digitales <- as.data.frame(df_list)
  
  # Renombrar las columnas del data frame
  colnames(datos_digitales) <- c("HR1", "HR2", "MHR", "TOCO", "MSpO2", "VCP", "Psistolica", "Pdiastolica", "Pmedia")
  
  # Crea la variable tiempo #by = 0.025
  tiempo <- seq(0, length.out = nrow(datos_digitales), by = 0.22)
  # Selecciona las primeras 2604 filas de tiempo
  tiempo <- head(tiempo, nrow(datos_digitales))
  
  # Añade la variable tiempo al data frame
  datos_digitales <- datos_digitales %>%
    mutate(tiempo = tiempo)
  
  # tiempo de registro
  hora <- ((((length(datos_digitales) / 9) / 4) / 60) / 60)
  min <- ((hora - floor(hora)) * 60)
  seg <- ((min - floor(min))) * 60
  
  tiempo_digital <- cbind(hora, min, seg)
  
  
###### cabecera analogica ######
  ficheroCA <- paste0(ruta, 'cabecera_FicheroAnalogico.DAT')
  f2 <- file(ficheroCA, 'rb')
  Cabecera_A1 <- readBin(f2, "integer", n=7, size=1, signed=FALSE)
  Cabecera_A2 <- readBin(f2, "integer", n=3, size=2, signed=TRUE)
  close(f2)
  
###### fichero analógico ######
  fichero <- paste0(ruta, 'ficheroAnalogico.DAT')
  f2 <- file(fichero, 'rb')
  datos_analogicos <- readBin(f2, "integer", n=20000000, size=2, signed=TRUE)
  close(f2)
  
  Fm <- 1000
  tiempo_analogico <- seq(from = 0, to = (length(datos_analogicos)-1)/Fm, by = 1/Fm)
  
  # Crear el data.frame de los datos
  datos_analogicos <- data.frame(tiempo_analogico, datos_analogicos)
  
  # Tiempo de registro
  hora <- ((length(datos_analogicos)/Fm)/60)/60
  min <- ((hora - floor(hora)) * 60)
  seg <- ((min - floor(min)) * 60)
  
  tiempo_analogico <- cbind(hora, min, seg)
  
  dfs <- list(datos_digitales, tiempo_digital, datos_analogicos, tiempo_analogico)
  vectores <- list(cabecera_digital, Cabecera_A1, Cabecera_A2)
  return(list(dfs, vectores))
}
```



```{r}
ruta <- "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/"
data <- get_data(ruta)

##Añadir variables para almacenar los datos de forma mas accesible##

#datos del fichero digital y total de tiempo de señal digital
datos_digitales <- as.data.frame(data[[1]][1])
tiempo_total_A <- as.data.frame(data[[1]][2])


#datos del fichero analogico y total de tiempo de señal analogica
datos_analogicos <- as.data.frame(data[[1]][3])
tiempo_total_A <- as.data.frame(data[[1]][4])


#datos de las cabeceras
cabecera_digital <- unlist(data[[2]][1])
cabecera_analogica1 <- unlist(data[[2]][2])
cabecera_analogica2 <- unlist(data[[2]][3])
```



```{r}
###### Grafico fichero analogico ######

#Obtenemos los datos de los 10 ultimos segundos de señal
datos_analogicos10 <- subset(datos_analogicos, tiempo_analogico > max(tiempo_analogico)-10)

#Representamos los ultimos 10 segundos de la señal atraves de un grafico interactivo
g <- ggplot(datos_analogicos10, aes(tiempo_analogico, datos_analogicos)) +
  geom_line(aes(col="red")) +
  labs(
    title = "Fichero Analogico",
    x = "time",
    y = "data"
  )
ggplotly(g)
```



```{r}
###### Grafico fichero digital ######
#seleccionamos los datos con tiempo menor a 1300
#2603
datos_digitales300 <- subset(datos_digitales, tiempo <= 300)

#adaptamos los datos para poder representarlos
datos_digitales300 <- gather(datos_digitales300, key = "variable", value = "valor", -tiempo)

#representamos los datos
ggplot(datos_digitales300, aes(x = tiempo, y = valor, color = variable)) +
  geom_line() +
  facet_wrap(~ variable, scales = "free") +
  labs(
    x = "Tiempo",
    y = "Valor",
  )
```

**Preguntas sobre la visualización de los datos y su utilidad:**

1.  **¿Por qué es necesario que analistas de datos hagan un estudio comparando diferentes casos de parto de un monitor fetal?** *Es necesario que los analistas de datos hagan un estudio comparando diferentes casos de parto de un monitor fetal para entender cómo se comportan los datos del monitor fetal en diferentes situaciones y para encontrar patrones y tendencias que puedan ser útiles para predecir y prevenir problemas de salud durante el parto. Al analizar una gran cantidad de datos de diferentes casos de parto, los analistas de datos pueden identificar patrones y tendencias que no serían visibles en un solo caso y desarrollar modelos predictivos para detectar signos tempranos de sufrimiento fetal o problemas de salud materna.*

2.  **¿Qué representa el HR1 y HR2 en la tabla de datos del monitor fetal?** *El HR1 y HR2 en la tabla de datos del monitor fetal representan dos canales diferentes de la frecuencia cardíaca fetal. La medición de la frecuencia cardíaca fetal en dos canales diferentes proporciona una mayor precisión en la detección de cambios en la frecuencia cardíaca fetal y ayuda a los profesionales de la salud a tomar decisiones más informadas sobre el cuidado y tratamiento del feto y la madre durante el parto.*

3.  **¿Cuál es el papel del equipo médico en la interpretación de los datos del monitor fetal?** *El equipo médico es responsable de interpretar los datos del monitor fetal y tomar decisiones clínicas basadas en esa información para garantizar la salud y seguridad de la madre y el feto durante el parto.*

4.  **¿Qué técnicas de análisis de datos son comúnmente utilizadas en el análisis de un monitor fetal?** *Las técnicas de análisis de datos comúnmente utilizadas en el análisis de un monitor fetal incluyen el análisis de series de tiempo, la modelización estadística y el aprendizaje automático. El análisis de series de tiempo se utiliza para analizar las variaciones en los datos del monitor fetal a lo largo del tiempo. La modelización estadística se utiliza para construir modelos que expliquen la relación entre las variables del monitor fetal. El aprendizaje automático se utiliza para identificar patrones y tendencias en los datos del monitor fetal que puedan ser difíciles de detectar mediante otros métodos.*
