---
title: "ProyectoTD2023"
author: "Jose Garcia Mora, Lucia Chulvi Deogracia"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
get_data <- function(ruta){
###### cabecera digital ######
  ficheroCD <- paste0(ruta, "cabecera_FicheroDigital.DAT")
  cabecera_digital <- readBin(con = ficheroCD, what = "integer", n = 8, size = 1, signed = FALSE)
  
###### fichero digital ######
  ficheroB <- paste0(ruta, "ficheroDigital.DAT")
  datos_digitales <- readBin(con = ficheroB, what = "integer", n = 2000000, size = 1, signed = FALSE)
  
  HR1 <- datos_digitales[seq(from = 1, to = length(datos_digitales), by = 9)]
  HR2 <- datos_digitales[seq(from = 2, to = length(datos_digitales), by = 9)]
  MHR <- datos_digitales[seq(from = 3, to = length(datos_digitales), by = 9)]
  TOCO <- datos_digitales[seq(from = 4, to = length(datos_digitales), by = 9)]
  MSpO2 <- datos_digitales[seq(from = 5, to = length(datos_digitales), by = 9)]
  VCP <- datos_digitales[seq(from = 6, to = length(datos_digitales), by = 9)]
  Psistolica <- datos_digitales[seq(from = 7, to = length(datos_digitales), by = 9)]
  Pdiastolica <- datos_digitales[seq(from = 8, to = length(datos_digitales), by = 9)]
  Pmedia <- datos_digitales[seq(from = 9, to = length(datos_digitales), by = 9)]
  
  mediaVCP <- mean(VCP) # cálculo de la media de la VCP
  
  # Almacenar las variables en una lista
  df_list <- list(HR1, HR2, MHR, TOCO, MSpO2, VCP, Psistolica, Pdiastolica, Pmedia)
  
  # Calcular el número máximo de filas
  max_filas <- max(sapply(df_list, length))
  
  # Recorrer cada vector en la lista
  for (i in 1:length(df_list)) {
    # Obtener el vector actual
    vector_actual <- df_list[[i]]
    # Calcular la mediana del vector
    mediana_actual <- median(vector_actual)
    
    # Comprobar si el vector necesita relleno
    if (length(vector_actual) < max_filas) {
      # Calcular el número de filas a rellenar
      filas_relleno <- max_filas - length(vector_actual)
      
      # Rellenar el vector con la mediana
      vector_relleno <- rep(mediana_actual, filas_relleno)
      
      # Concatenar el vector original y el vector de relleno
      df_list[[i]] <- c(vector_actual, vector_relleno)
    }
  }
  
  # Convertir la lista en un data frame
  datos_digitales <- as.data.frame(df_list)
  
  # Renombrar las columnas del data frame
  colnames(datos_digitales) <- c("HR1", "HR2", "MHR", "TOCO", "MSpO2", "VCP", "Psistolica", "Pdiastolica", "Pmedia")
  
  # Crea la variable tiempo
  tiempo <- seq(0, length.out = nrow(datos_digitales), by = 0.025)
  # Selecciona las primeras 2604 filas de tiempo
  tiempo <- head(tiempo, nrow(datos_digitales))
  
  # Añade la variable tiempo al data frame
  datos_digitales <- datos_digitales %>%
    mutate(tiempo = tiempo)
  
  # tiempo de registro
  hora <- ((((length(datos_digitales) / 9) / 4) / 60) / 60)
  min <- ((hora - floor(hora)) * 60)
  seg <- ((min - floor(min))) * 60
  
  tiempo_digital <- cbind(hora, min, seg)
  
  
###### cabecera analogica ######
  ficheroCA <- paste0(ruta, 'cabecera_FicheroAnalogico.DAT')
  f2 <- file(ficheroCA, 'rb')
  Cabecera_A1 <- readBin(f2, "integer", n=7, size=1, signed=FALSE)
  Cabecera_A2 <- readBin(f2, "integer", n=3, size=2, signed=TRUE)
  close(f2)
  
###### fichero analógico ######
  fichero <- paste0(ruta, 'ficheroAnalogico.DAT')
  f2 <- file(fichero, 'rb')
  datos_analogicos <- readBin(f2, "integer", n=20000000, size=2, signed=TRUE)
  close(f2)
  
  # Calcular el vector de tiempo t
  Fm <- 1000
  t <- seq(from = 0, to = (length(datos_analogicos)-1)/Fm, by = 1/Fm)
  
  # Crear el data.frame de los datos
  datos_analogicos <- data.frame(t, datos_analogicos)
  
  # Tiempo de registro
  hora <- ((length(datos_analogicos)/Fm)/60)/60
  min <- ((hora - floor(hora)) * 60)
  seg <- ((min - floor(min)) * 60)
  
  tiempo_analogico <- cbind(hora, min, seg)
  
  dfs <- list(datos_digitales, tiempo_digital,datos_analogicos, tiempo_analogico)
  vectores <- list(cabecera_digital, Cabecera_A1, Cabecera_A2)
  return(list(dfs, vectores))
}


ruta <- "data/1059xlxveei79_ECGf2/27_09_2022/14.42.29_III_ECGyEXTyRESTO/"
data <- get_data(ruta)

#Añadir variables para almacenar los datos de forma mas accesible
datos_digitales <- data[[1]][1]
head(datos_digitales)
```

**Preguntas sobre la visualización de los datos y su utilidad:**

1.  **¿Por qué es necesario que analistas de datos hagan un estudio comparando diferentes casos de parto de un monitor fetal?** *Es necesario que los analistas de datos hagan un estudio comparando diferentes casos de parto de un monitor fetal para entender cómo se comportan los datos del monitor fetal en diferentes situaciones y para encontrar patrones y tendencias que puedan ser útiles para predecir y prevenir problemas de salud durante el parto. Al analizar una gran cantidad de datos de diferentes casos de parto, los analistas de datos pueden identificar patrones y tendencias que no serían visibles en un solo caso y desarrollar modelos predictivos para detectar signos tempranos de sufrimiento fetal o problemas de salud materna.*

2.  **¿Qué representa el HR1 y HR2 en la tabla de datos del monitor fetal?** *El HR1 y HR2 en la tabla de datos del monitor fetal representan dos canales diferentes de la frecuencia cardíaca fetal. La medición de la frecuencia cardíaca fetal en dos canales diferentes proporciona una mayor precisión en la detección de cambios en la frecuencia cardíaca fetal y ayuda a los profesionales de la salud a tomar decisiones más informadas sobre el cuidado y tratamiento del feto y la madre durante el parto.*

3.  **¿Cuál es el papel del equipo médico en la interpretación de los datos del monitor fetal?** *El equipo médico es responsable de interpretar los datos del monitor fetal y tomar decisiones clínicas basadas en esa información para garantizar la salud y seguridad de la madre y el feto durante el parto.*

4.  **¿Qué técnicas de análisis de datos son comúnmente utilizadas en el análisis de un monitor fetal?** *Las técnicas de análisis de datos comúnmente utilizadas en el análisis de un monitor fetal incluyen el análisis de series de tiempo, la modelización estadística y el aprendizaje automático. El análisis de series de tiempo se utiliza para analizar las variaciones en los datos del monitor fetal a lo largo del tiempo. La modelización estadística se utiliza para construir modelos que expliquen la relación entre las variables del monitor fetal. El aprendizaje automático se utiliza para identificar patrones y tendencias en los datos del monitor fetal que puedan ser difíciles de detectar mediante otros métodos.*
